// Defines the code generated by the block.

// 初始化
Blockly.Arduino['picar_init'] = function(block) {
  // Global definitions
  // 前置處理
  Blockly.Arduino.definitions_['define_preprocess'] = 
    '#include <Servo.h>  // for servo\n' +
    '#include <Adafruit_NeoPixel.h>  // for RGB LED, install Adafruit NeoPixel lib first\n';
  
  // 全域變數
  Blockly.Arduino.definitions_['define_g_hand_range'] = 'int g_hand_range = 170;  // 手臂開合角度最大範圍'; // Default value

  // 腳位定義
  Blockly.Arduino.definitions_['define_picar_pins'] =
    'const int pinM1A = 8;  // left motor A pin\n' +
    'const int pinM1B = 9;  // left motor B pin\n' +
    'const int pinM2A = 10;  // right motor A pin\n' +
    'const int pinM2B = 11;  // right motor B pin\n\n' +
    'const int pinServoL = 12;  // left servo pin\n' +
    'const int pinServoR = 13;  // right servo pin\n' +
    'Servo handL;  // left servo\n' +
    'Servo handR;  // right servo\n\n' +
    'const int pinBtnStart = 20;  // start button pin\n' +
    'const int pinBuzzer = 22;  // piezo buzzer pin\n' +
    'const int pinIR_D = 26;  // IR digital\n' +
    'const int pinIR_A = 27;  // IR analog\n' +
    'const int pinTrig = 28;  // ultrasonic Trig\n' +
    'const int pinEcho = 7;  // ultrasonic Echo\n\n' +
    'const int pinRGB = 18;  // RGB LED pin\n\n' +
    '// 創建 NeoPixel 燈條物件 strip \n' +
    '// 設定(個數,腳位,RGB傳送順序+通訊速率)\n' +
    '// WS2812B燈條的顏色傳送順序是 GRB, 工作頻率是 800 KHz\n' +
    'Adafruit_NeoPixel strip(2, pinRGB, NEO_GRB + NEO_KHZ800);\n\n';

  // 函數定義
  // 重置
  Blockly.Arduino.definitions_['define_resetPiCar'] =
    'void resetPiCar() {  // restart PiCar\n' +
    '  watchdog_reboot(0, 0, 0);\n' +
    '}\n';

  // 左右直流馬達動力
  Blockly.Arduino.definitions_['define_drive'] =
    'void drive(int powerL, int powerR) {  // left and right motor control\n' +
    '  // powerL: Left motor direction and power.\n' +
    '  // powerR: Right motor direction and power.\n\n' +
    '  powerL = constrain(powerL, -255, 255);  // -255<= powerL <= 255\n' +
    '  powerR = constrain(powerR, -255, 255);  // -255<= powerR <= 255\n\n' +
    '  if (powerL > 0) {\n' +
    '    analogWrite(pinM1A, powerL);\n' +
    '    analogWrite(pinM1B, 0);\n' +
    '  } else {\n' +
    '    analogWrite(pinM1A, 0);\n' +
    '    analogWrite(pinM1B, -powerL);\n' +
    '  }\n' +
    '  if (powerR > 0) {\n' +
    '    analogWrite(pinM2A, powerR);\n' +
    '    analogWrite(pinM2B, 0);\n' +
    '  } else {\n' +
    '    analogWrite(pinM2A, 0);\n' +
    '    analogWrite(pinM2B, -powerR);\n' +
    '  }\n' +
    '}\n';


  // 滑行
  Blockly.Arduino.definitions_['define_coast'] =
    'void coast() {  // stop the car and coast\n' +
    '  analogWrite(pinM1A, 255);\n' +
    '  analogWrite(pinM1B, 255);\n' +
    '  analogWrite(pinM2A, 255);\n' +
    '  analogWrite(pinM2B, 255);\n' +
    '  delay(1000);\n' +
    '}\n';


  // 剎車
  Blockly.Arduino.definitions_['define_brake'] =
    'void brake() {  // stop the car and brake\n' +
    '  analogWrite(pinM1A, 0);\n' +
    '  analogWrite(pinM1B, 0);\n' +
    '  analogWrite(pinM2A, 0);\n' +
    '  analogWrite(pinM2B, 0);\n' +
    '  delay(500);\n' +
    '}\n';

  // 超音波測距
  Blockly.Arduino.definitions_['define_checkDistance'] =
    'float checkDistance() {  // detection distance\n' +
    '  // Use ultrasonic to detect the distance of obstacles in centimeters.\n' +
    '  digitalWrite(pinTrig, LOW);\n' +
    '  delayMicroseconds(2);\n' +
    '  digitalWrite(pinTrig, HIGH);\n' +
    '  delayMicroseconds(10);\n' +
    '  digitalWrite(pinTrig, LOW);\n\n' +
    '  // Measure the response from the HC-SR04P Echo Pin.\n' +
    '  int duration = pulseIn(pinEcho, HIGH);\n\n' +
    '  // Determine distance from duration\n' +
    '  // Use 340 meters per second as speed of sound\n' +
    '  float distance = duration * 0.034 / 2;\n' +
    '  delay(20);  // Pause to prevent frequent reading\n' +
    '  return distance;\n' +
    '}\n';

  // 紅外線反射(數位)
  Blockly.Arduino.definitions_['define_checkColor'] =
    'int checkColor() {  // detection black and white\n' +
    '  // Use digital signals from infrared reflective sensor to detect black and white.\n' +
    '  // Returns 0 for black and 1 for white.\n' +
    '  int IR_D = digitalRead(pinIR_D);  // 0:white  1:black\n' +
    '  delay(1);  // Pause to prevent noise caused by frequent reads.\n' +
    '  return !IR_D;  // Invert, 0:black  1:white\n' +
    '}\n';

  // 手臂初始位置
  Blockly.Arduino.definitions_['define_inPosition'] =
    'void inPosition(){  // Servo motor initial positioning\n' +
    '  handL.write(180);\n' +
    '  handR.write(0);\n' +
    '  delay(1000);\n' +
    '}\n';


  // 手臂合起
  Blockly.Arduino.definitions_['define_closeHands'] =
    'void closeHands(){\n' +
    '  for (int i = 0; i <= g_hand_range; i++){\n' +
    '    handL.write(180-i);\n' +
    '    handR.write(i);\n' +
    '    delay(7);\n' +
    '  }\n' +
    '}\n';


    // 手臂張開
    Blockly.Arduino.definitions_['define_openHands'] = 
      'void openHands(){\n' +
      '  for (int i = 0; i <= g_hand_range; i++){\n' +
      '    handL.write(i+180-g_hand_range);\n' +
      '    handR.write(g_hand_range-i);\n' +
      '    delay(7);\n' +
      '  }\n' +
      '}\n';
  
    // 設定左手角度
    Blockly.Arduino.definitions_['define_setLeftHandAngle'] = 
      'void setLeftHandAngle(int angle){\n' +
      '  angle = constrain(angle, 0, 180);\n' +
      '  handL.write(angle);\n' +
      '}\n';
  
    // 設定右手角度
    Blockly.Arduino.definitions_['define_setRightHandAngle'] = 
      'void setRightHandAngle(int angle){\n' +
      '  angle = constrain(angle, 0, 180);\n' +
      '  handR.write(angle);\n' +
      '}\n';
  
  // 燈光閃爍
  Blockly.Arduino.definitions_['define_flashingLight'] =
    'void flashingLight(){\n' +
    '  strip.setPixelColor(0, strip.Color(255, 0, 0));\n' +
    '  strip.setPixelColor(1, strip.Color(0, 0, 255));\n' +
    '  strip.show();\n' +
    '  delay(500);\n' +
    '  strip.setPixelColor(0, strip.Color(0, 0, 0));\n' +
    '  strip.setPixelColor(1, strip.Color(0, 0, 0));\n' +
    '  strip.show();\n' +
    '  delay(500);\n' +
    '}\n';

  // 命運主題
  Blockly.Arduino.definitions_['define_easterEgg'] =
    'void easterEgg(int tempo){\n' +
    '  // https://zh.wikipedia.org/zh-tw/%E9%9F%B3%E9%AB%98\n' +
    '  // notes in the melody:\n' +
    '  int melody[] = {\n' +
    '    0, 392, 392, 392, 311\n' +
    '  };\n\n' +
    '  // note durations: 4 = quarter note, 8 = eighth note, etc.:\n' +
    '  int noteDurations[] = {\n' +
    '    8, 12, 12, 12, 2\n' +
    '  };\n\n' +
    '  // iterate over the notes of the melody:\n' +
    '  for (int i = 0; i < sizeof(melody)/sizeof(int); i++) {\n' +
    '    // to calculate the note duration, take one second divided by the note type.\n' +
    '    //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc.\n' +
    '    int noteDuration = tempo / noteDurations[i];\n' +
    '    tone(pinBuzzer, melody[i], noteDuration);\n\n' +
    '    // to distinguish the notes, set a minimum time between them.\n' +
    '    // the note\'s duration + 30% seems to work well:\n' +
    '    int pauseBetweenNotes = noteDuration * 1.30;\n' +
    '    delay(pauseBetweenNotes);\n\n' +
    '    // stop the tone playing:\n' +
    '    noTone(pinBuzzer);\n' +
    '  }  //end for\n' +
    '}\n';


  // Setup code to be added to the Arduino setup() function
  Blockly.Arduino.setups_['setup_serial'] = 'Serial.begin(9600);\n\n';

  Blockly.Arduino.setups_['setup_button'] = 'pinMode(pinBtnStart, INPUT_PULLUP);  // enable pull-up resistor';
  Blockly.Arduino.setups_['setup_buzzer'] = 'pinMode(pinBuzzer, OUTPUT);\n';

  Blockly.Arduino.setups_['setup_ultrasonic'] = 'pinMode(pinTrig, OUTPUT);  // Ultrasonic HC-SR04P Trig\n  pinMode(pinEcho, INPUT);  // Ultrasonic HC-SR04P Echo\n';

  Blockly.Arduino.setups_['setup_ir'] = 'pinMode(pinIR_D, INPUT);  //IR digital\n  pinMode(pinIR_A, INPUT);  //IR analog\n';

  Blockly.Arduino.setups_['setup_motors'] = 'pinMode(pinM1A, OUTPUT);  //Motor left A\n  pinMode(pinM1B, OUTPUT);  //Motor left B\n  pinMode(pinM2A, OUTPUT);  //Motor right A\n  pinMode(pinM2B, OUTPUT);  //Motor right B\n';
  Blockly.Arduino.setups_['setup_servos'] = 'handL.attach(pinServoL, 460, 2400);  // Servo left， 最小與最大PWM寬度(µs)，對應 0° 到 180°，每批貨都有些微出入\n  handR.attach(pinServoR, 460, 2400);  // Servo right\n  inPosition();  // initial positioning\n';

  Blockly.Arduino.setups_['setup_rgb_led'] = 'strip.begin();  // initialize RGB LED\n  strip.setBrightness(10);  // set brightness, 0~255';

  Blockly.Arduino.setups_['setup_easter_egg'] = '//easterEgg(1000);  // watch out!\n';
  Blockly.Arduino.setups_['setup_beep'] = 'tone(pinBuzzer, 440, 200);  // watch out!\n';
  Blockly.Arduino.setups_['setup_wait_button'] = 'while (digitalRead(pinBtnStart)) {  // Wait for button event\n    // I haven\'t pressed the start button yet, just idling here waiting.\n  }\n  delay(500);\n\n  //Your code starts here...';

  return ''; // This block doesnot generate code directly in the loop
};


// 手臂開合角度最大範圍
Blockly.Arduino['picar_set_hand_range'] = function(block) {
  var range = Blockly.Arduino.valueToCode(block, 'RANGE', Blockly.Arduino.ORDER_ATOMIC) || '170';
  Blockly.Arduino.definitions_['define_g_hand_range'] = 'int g_hand_range = ' + range + ';';
  return '';
};


// 重置
Blockly.Arduino['picar_resetPiCar'] = function(block) {
  return 'resetPiCar();\n';
};



// 左右直流馬達動力
Blockly.Arduino['picar_drive'] = function(block) {
  // Get the input values
  var value_power_l = Blockly.Arduino.valueToCode(block, 'POWER_L', Blockly.Arduino.ORDER_ATOMIC) || '0';
  var value_power_r = Blockly.Arduino.valueToCode(block, 'POWER_R', Blockly.Arduino.ORDER_ATOMIC) || '0';
  
  // Generate the function call
  var code = 'drive(' + value_power_l + ', ' + value_power_r + ');\n';
  return code;
};

// 停車
Blockly.Arduino['picar_stop'] = function(block) {
  var dropdown_mode = block.getFieldValue('MODE');
  var code = '';
  if (dropdown_mode == 'COAST') {
    code = 'coast();\n';
  } else if (dropdown_mode == 'BRAKE') {
    code = 'brake();\n';
  }
  return code;
};


// 超音波測距
Blockly.Arduino['picar_checkDistance'] = function(block) {
  var code = 'checkDistance()';
  return [code, Blockly.Arduino.ORDER_ATOMIC];
};


// 紅外線反射(數位)
Blockly.Arduino['picar_checkColor'] = function(block) {
  var code = 'checkColor()';
  return [code, Blockly.Arduino.ORDER_ATOMIC];
};


// 手臂初始位置
Blockly.Arduino['picar_inPosition'] = function(block) {
  return 'inPosition();\n';
};

// 設定左手角度
Blockly.Arduino['simfonia_set_left_hand_angle'] = function(block) {
  var angle = Blockly.Arduino.valueToCode(block, 'ANGLE', Blockly.Arduino.ORDER_ATOMIC) || '180';
  return 'setLeftHandAngle(' + angle + ');\n';
};

// 設定右手角度
Blockly.Arduino['simfonia_set_right_hand_angle'] = function(block) {
  var angle = Blockly.Arduino.valueToCode(block, 'ANGLE', Blockly.Arduino.ORDER_ATOMIC) || '0';
  return 'setRightHandAngle(' + angle + ');\n';
};

// 手臂合起
Blockly.Arduino['picar_closeHands'] = function(block) {
  return 'closeHands();\n';
};


// 手臂張開
Blockly.Arduino['picar_openHands'] = function(block) {
  return 'openHands();\n';
};


// 設定RGB燈顏色
Blockly.Arduino['picar_set_led_color'] = function(block) {
  var ledIndex = block.getFieldValue('LED_INDEX');
  var color = block.getFieldValue('COLOR');
  // Convert hex color to R, G, B
  var r = parseInt(color.substring(1, 3), 16);
  var g = parseInt(color.substring(3, 5), 16);
  var b = parseInt(color.substring(5, 7), 16);

  var code = '';
  if (ledIndex === 'ALL') {
    code += 'strip.setPixelColor(0, strip.Color(' + r + ', ' + g + ', ' + b + '));\n';
    code += 'strip.setPixelColor(1, strip.Color(' + r + ', ' + g + ', ' + b + '));\n';
  } else {
    code += 'strip.setPixelColor(' + ledIndex + ', strip.Color(' + r + ', ' + g + ', ' + b + '));\n';
  }
  code += 'strip.show();\n';
  return code;
};


// 燈光閃爍
Blockly.Arduino['picar_flashingLight'] = function(block) {
  return 'flashingLight();\n';
};


// 播放彩蛋旋律
Blockly.Arduino['picar_easterEgg'] = function(block) {
  var tempo = Blockly.Arduino.valueToCode(block, 'TEMPO', Blockly.Arduino.ORDER_ATOMIC) || '1000';
  return 'easterEgg(' + tempo + ');\n';
};


// 自由寫
Blockly.Arduino['coding_raw_statement'] = function(block) {
  var code = block.getFieldValue('CODE');
  return code + '\n'; // Output the text as-is, with a newline
};


Blockly.Arduino['coding_raw_input'] = function(block) {
  var code = block.getFieldValue('CODE');
  return [code, Blockly.Arduino.ORDER_ATOMIC];
};

Blockly.Arduino['coding_raw_definition'] = function(block) {
  var code = block.getFieldValue('CODE');
  Blockly.Arduino.definitions_['raw_definition_' + block.id] = code;
  return '';
};

Blockly.Arduino['coding_raw_wrapper'] = function(block) {
  var codeTop = block.getFieldValue('CODE_TOP');
  var statementsDo = Blockly.Arduino.statementToCode(block, 'DO');
  var codeBottom = block.getFieldValue('CODE_BOTTOM');
  var code = codeTop + '\n' + statementsDo + codeBottom + '\n';
  return code;
};


Blockly.Arduino['arduino_pin_mode'] = function(block) {
  var pin = Blockly.Arduino.valueToCode(block, 'PIN', Blockly.Arduino.ORDER_ATOMIC) || '0';
  var mode = Blockly.Arduino.valueToCode(block, 'MODE', Blockly.Arduino.ORDER_ATOMIC) || 'OUTPUT';
  var code = 'pinMode(' + pin + ', ' + mode + ');\n';
  return code;
};

Blockly.Arduino['arduino_pin_mode_mode_shadow'] = function(block) {
  var mode = block.getFieldValue('MODE');
  return [mode, Blockly.Arduino.ORDER_ATOMIC];
};

Blockly.Arduino['arduino_pin_shadow'] = function(block) {
  var pin = block.getFieldValue('PIN');
  return [pin, Blockly.Arduino.ORDER_ATOMIC];
};


Blockly.Arduino['arduino_digital_read'] = function(block) {
  var pin = Blockly.Arduino.valueToCode(block, 'PIN', Blockly.Arduino.ORDER_ATOMIC) || '0';
  var code = 'digitalRead(' + pin + ')';
  return [code, Blockly.Arduino.ORDER_ATOMIC];
};

Blockly.Arduino['arduino_digital_write'] = function(block) {
  var pin = Blockly.Arduino.valueToCode(block, 'PIN', Blockly.Arduino.ORDER_ATOMIC) || '0';
  var value = block.getFieldValue('VALUE');
  var code = 'digitalWrite(' + pin + ', ' + value + ');\n';
  return code;
};


Blockly.Arduino['arduino_analog_read'] = function(block) {
  var pin = Blockly.Arduino.valueToCode(block, 'PIN', Blockly.Arduino.ORDER_ATOMIC) || 'A0';
  var code = 'analogRead(' + pin + ')';
  return [code, Blockly.Arduino.ORDER_ATOMIC];
};

Blockly.Arduino['arduino_analog_write'] = function(block) {
  var pin = Blockly.Arduino.valueToCode(block, 'PIN', Blockly.Arduino.ORDER_ATOMIC) || '3';
  var value = Blockly.Arduino.valueToCode(block, 'VALUE', Blockly.Arduino.ORDER_ATOMIC) || '0';
  var code = 'analogWrite(' + pin + ', ' + value + ');\n';
  return code;
};

Blockly.Arduino['arduino_constrain'] = function(block) {
  var value = Blockly.Arduino.valueToCode(block, 'VALUE', Blockly.Arduino.ORDER_ATOMIC) || '0';
  var low = Blockly.Arduino.valueToCode(block, 'LOW', Blockly.Arduino.ORDER_ATOMIC) || '0';
  var high = Blockly.Arduino.valueToCode(block, 'HIGH', Blockly.Arduino.ORDER_ATOMIC) || '0';
  var code = 'constrain(' + value + ', ' + low + ', ' + high + ')';
  return [code, Blockly.Arduino.ORDER_ATOMIC];
};

Blockly.Arduino['arduino_map'] = function(block) {
  var value = Blockly.Arduino.valueToCode(block, 'VALUE', Blockly.Arduino.ORDER_ATOMIC) || '0';
  var fromLow = Blockly.Arduino.valueToCode(block, 'FROMLOW', Blockly.Arduino.ORDER_ATOMIC) || '0';
  var fromHigh = Blockly.Arduino.valueToCode(block, 'FROMHIGH', Blockly.Arduino.ORDER_ATOMIC) || '0';
  var toLow = Blockly.Arduino.valueToCode(block, 'TOLOW', Blockly.Arduino.ORDER_ATOMIC) || '0';
  var toHigh = Blockly.Arduino.valueToCode(block, 'TOHIGH', Blockly.Arduino.ORDER_ATOMIC) || '0';
  var code = 'map(' + value + ', ' + fromLow + ', ' + fromHigh + ', ' + toLow + ', ' + toHigh + ')';
  return [code, Blockly.Arduino.ORDER_ATOMIC];
};
