// Defines the code generated by the block.

// 初始化
Blockly.Arduino['picar_init'] = function(block) {
  // Global definitions
  // 前置處理
  Blockly.Arduino.definitions_['define_preprocess'] = 
    '#include <Servo.h>  // for servo\n' +
    '#include <Adafruit_NeoPixel.h>  // for RGB LED, install Adafruit NeoPixel lib first\n';
  
  // 全域變數
  Blockly.Arduino.definitions_['define_g_hand_range'] = 'int g_hand_range = 170;  // 手臂開合角度最大範圍'; // Default value

  // 腳位定義
  Blockly.Arduino.definitions_['define_picar_pins'] =
    'const int pinM1A = 8;  // left motor A pin\n' +
    'const int pinM1B = 9;  // left motor B pin\n' +
    'const int pinM2A = 10;  // right motor A pin\n' +
    'const int pinM2B = 11;  // right motor B pin\n\n' +
    'const int pinServoL = 12;  // left servo pin\n' +
    'const int pinServoR = 13;  // right servo pin\n' +
    'Servo handL;  // left servo\n' +
    'Servo handR;  // right servo\n\n' +
    'const int pinBtnStart = 20;  // start button pin\n' +
    'const int pinBuzzer = 22;  // piezo buzzer pin\n' +
    'const int pinIR_D = 26;  // IR digital\n' +
    'const int pinIR_A = 27;  // IR analog\n' +
    'const int pinTrig = 28;  // ultrasonic Trig\n' +
    'const int pinEcho = 7;  // ultrasonic Echo\n\n' +
    'const int pinRGB = 18;  // RGB LED pin\n\n' +
    '// 創建 NeoPixel 燈條物件 strip \n' +
    '// 設定(個數,腳位,RGB傳送順序+通訊速率)\n' +
    '// WS2812B燈條的顏色傳送順序是 GRB, 工作頻率是 800 KHz\n' +
    'Adafruit_NeoPixel strip(2, pinRGB, NEO_GRB + NEO_KHZ800);\n';

  // 函數定義
  // 重置
  Blockly.Arduino.definitions_['define_resetPiCar'] =
    'void resetPiCar() {  // restart PiCar\n' +
    '  watchdog_reboot(0, 0, 0);\n' +
    '}\n';

  // 左右直流馬達動力
  Blockly.Arduino.definitions_['define_drive'] =
    'void drive(int powerL, int powerR) {  // left and right motor control\n' +
    '  // powerL: Left motor direction and power.\n' +
    '  // powerR: Right motor direction and power.\n\n' +
    '  powerL = constrain(powerL, -255, 255);  // -255<= powerL <= 255\n' +
    '  powerR = constrain(powerR, -255, 255);  // -255<= powerR <= 255\n\n' +
    '  if (powerL > 0) {\n' +
    '    analogWrite(pinM1A, powerL);\n' + 
    '    analogWrite(pinM1B, 0);\n' + 
    '  } else {\n' +
    '    analogWrite(pinM1A, 0);\n' +
    '    analogWrite(pinM1B, -powerL);\n' +
    '  }\n' +
    '  if (powerR > 0) {\n' +
    '    analogWrite(pinM2A, powerR);\n' +
    '    analogWrite(pinM2B, 0);\n' +
    '  } else {\n' +
    '    analogWrite(pinM2A, 0);\n' +
    '    analogWrite(pinM2B, -powerR);\n' +
    '  }\n' +
    '}\n';


  // 滑行
  Blockly.Arduino.definitions_['define_coast'] =
    'void coast() {  // stop the car and coast\n' +
    '  analogWrite(pinM1A, 255);\n' +
    '  analogWrite(pinM1B, 255);\n' +
    '  analogWrite(pinM2A, 255);\n' +
    '  analogWrite(pinM2B, 255);\n' +
    '  delay(1000);\n' +
    '}\n';


  // 剎車
  Blockly.Arduino.definitions_['define_brake'] =
    'void brake() {  // stop the car and brake\n' +
    '  analogWrite(pinM1A, 0);\n' +
    '  analogWrite(pinM1B, 0);\n' +
    '  analogWrite(pinM2A, 0);\n' +
    '  analogWrite(pinM2B, 0);\n' +
    '  delay(500);\n' +
    '}\n';

  // 超音波測距
  Blockly.Arduino.definitions_['define_checkDistance'] =
    'float checkDistance() {  // detection distance\n' +
    '  // Use ultrasonic to detect the distance of obstacles in centimeters.\n' +
    '  digitalWrite(pinTrig, LOW);\n' +
    '  delayMicroseconds(2);\n' +
    '  digitalWrite(pinTrig, HIGH);\n' +
    '  delayMicroseconds(10);\n' +
    '  digitalWrite(pinTrig, LOW);\n\n' +
    '  // Measure the response from the HC-SR04P Echo Pin.\n' + 
    '  int duration = pulseIn(pinEcho, HIGH);\n\n' +
    '  // Determine distance from duration\n' +
    '  // Use 340 meters per second as speed of sound\n' +
    '  float distance = duration * 0.034 / 2;\n' +
    '  delay(20);  // Pause to prevent frequent reading\n' +
    '  return distance;\n' +
    '}\n';

  // 紅外線反射(數位)
  Blockly.Arduino.definitions_['define_checkColor'] =
    'int checkColor() {  // detection black and white\n' +
    '  // Use digital signals from infrared reflective sensor to detect black and white.\n' +
    '  // Returns 0 for black and 1 for white.\n' +
    '  int IR_D = digitalRead(pinIR_D);  // 0:white  1:black\n' +
    '  delay(1);  // Pause to prevent noise caused by frequent reads.\n' +
    '  return !IR_D;  // Invert, 0:black  1:white\n' +
    '}\n';

  // 手臂初始位置
  Blockly.Arduino.definitions_['define_inPosition'] =
    'void inPosition(){  // Servo motor initial positioning\n' +
    '  handL.write(180);\n' +
    '  handR.write(0);\n' +
    '  delay(1000);\n' +
    '}\n';


  // 手臂合起
  Blockly.Arduino.definitions_['define_closeHands'] =
    'void closeHands(){\n' +
    '  for (int i = 0; i <= g_hand_range; i++){\n' +
    '    handL.write(180-i);\n' +
    '    handR.write(i);\n' +
    '    delay(7);\n' +
    '  }\n' +
    '}\n';


  // 手臂張開
  Blockly.Arduino.definitions_['define_openHands'] =
    'void openHands(){\n' +
    '  for (int i = 0; i <= g_hand_range; i++){\n' +
    '    handL.write(i+180-g_hand_range);\n' +
    '    handR.write(g_hand_range-i);\n' +
    '    delay(7);\n' +
    '  }\n' +
    '}\n';

  // 燈光閃爍
  Blockly.Arduino.definitions_['define_flashingLight'] =
    'void flashingLight(){\n' +
    '  strip.setPixelColor(0, strip.Color(255, 0, 0));\n' +
    '  strip.setPixelColor(1, strip.Color(0, 0, 255));\n' +
    '  strip.show();\n' +
    '  delay(500);\n' +
    '  strip.setPixelColor(0, strip.Color(0, 0, 0));\n' +
    '  strip.setPixelColor(1, strip.Color(0, 0, 0));\n' +
    '  strip.show();\n' +
    '  delay(500);\n' +
    '}\n';

  // 命運主題
  Blockly.Arduino.definitions_['define_easterEgg'] =
    'void easterEgg(int tempo){\n' +
    '  // https://zh.wikipedia.org/zh-tw/%E9%9F%B3%E9%AB%98\n' +
    '  // notes in the melody:\n' +
    '  int melody[] = {\n' +
    '    0, 392, 392, 392, 311\n' +
    '  };\n\n' +
    '  // note durations: 4 = quarter note, 8 = eighth note, etc.:\n' +
    '  int noteDurations[] = {\n' +
    '    8, 12, 12, 12, 2\n' +
    '  };\n\n' +
    '  // iterate over the notes of the melody:\n' +
    '  for (int i = 0; i < sizeof(melody)/sizeof(int); i++) {\n' +
    '    // to calculate the note duration, take one second divided by the note type.\n' +
    '    //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc.\n' +
    '    int noteDuration = tempo / noteDurations[i];\n' +
    '    tone(pinBuzzer, melody[i], noteDuration);\n\n' +
    '    // to distinguish the notes, set a minimum time between them.\n' +
    '    // the note\'s duration + 30% seems to work well:\n' +
    '    int pauseBetweenNotes = noteDuration * 1.30;\n' +
    '    delay(pauseBetweenNotes);\n\n' +
    '    // stop the tone playing:\n' +
    '    noTone(pinBuzzer);\n' +
    '  }  //end for\n' +
    '}\n';


  // Setup code to be added to the Arduino setup() function
  Blockly.Arduino.setups_['setup_serial'] = 'Serial.begin(9600);\n\n';

  Blockly.Arduino.setups_['setup_button'] = 'pinMode(pinBtnStart, INPUT_PULLUP);  // enable pull-up resistor';
  Blockly.Arduino.setups_['setup_buzzer'] = 'pinMode(pinBuzzer, OUTPUT);\n';

  Blockly.Arduino.setups_['setup_ultrasonic'] = 'pinMode(pinTrig, OUTPUT);  // Ultrasonic HC-SR04P Trig\n  pinMode(pinEcho, INPUT);  // Ultrasonic HC-SR04P Echo\n';

  Blockly.Arduino.setups_['setup_ir'] = 'pinMode(pinIR_D, INPUT);  //IR digital\n  pinMode(pinIR_A, INPUT);  //IR analog\n';

  Blockly.Arduino.setups_['setup_motors'] = 'pinMode(pinM1A, OUTPUT);  //Motor left A\n  pinMode(pinM1B, OUTPUT);  //Motor left B\n  pinMode(pinM2A, OUTPUT);  //Motor right A\n  pinMode(pinM2B, OUTPUT);  //Motor right B\n';
  Blockly.Arduino.setups_['setup_servos'] = 'handL.attach(pinServoL, 460, 2400);  // Servo left， 最小與最大PWM寬度(µs)，對應 0° 到 180°，每批貨都有些微出入\n  handR.attach(pinServoR, 460, 2400);  // Servo right\n  inPosition();  // initial positioning\n';

  Blockly.Arduino.setups_['setup_rgb_led'] = 'strip.begin();  // initialize RGB LED\n  strip.setBrightness(10);  // set brightness, 0~255';

  Blockly.Arduino.setups_['setup_easter_egg'] = '//easterEgg(1000);  // watch out!\n';
  Blockly.Arduino.setups_['setup_beep'] = 'tone(pinBuzzer, 440, 200);  // watch out!\n';
  Blockly.Arduino.setups_['setup_wait_button'] = 'while (digitalRead(pinBtnStart)) {  // Wait for button event\n    // I haven\'t pressed the start button yet, just idling here waiting.\n  }\n  delay(500);\n\n  //Your code starts here...';

  return ''; // This block doesn\'t generate code directly in the loop
};


// 手臂開合角度最大範圍
Blockly.Arduino['picar_set_hand_range'] = function(block) {
  var range = Blockly.Arduino.valueToCode(block, 'RANGE', Blockly.Arduino.ORDER_ATOMIC) || '170';
  Blockly.Arduino.definitions_['define_g_hand_range'] = 'int g_hand_range = ' + range + ';';
  return '';
};


// 重置
Blockly.Arduino['picar_resetPiCar'] = function(block) {
  return 'resetPiCar();\n';
};



// 左右直流馬達動力
Blockly.Arduino['picar_drive'] = function(block) {
  // Get the input values
  var value_power_l = Blockly.Arduino.valueToCode(block, 'POWER_L', Blockly.Arduino.ORDER_ATOMIC) || '0';
  var value_power_r = Blockly.Arduino.valueToCode(block, 'POWER_R', Blockly.Arduino.ORDER_ATOMIC) || '0';
  
  // Generate the function call
  var code = 'drive(' + value_power_l + ', ' + value_power_r + ');\n';
  return code;
};

// 滑行
Blockly.Arduino['picar_coast'] = function(block) {
  var code = 'coast();\n';
  return code;
};


// 煞車
Blockly.Arduino['picar_brake'] = function(block) {
  var code = 'brake();\n';
  return code;
};


// 超音波測距
Blockly.Arduino['picar_checkDistance'] = function(block) {
  var code = 'checkDistance()';
  return [code, Blockly.Arduino.ORDER_ATOMIC];
};


// 紅外線反射(數位)
Blockly.Arduino['picar_checkColor'] = function(block) {
  var code = 'checkColor()';
  return [code, Blockly.Arduino.ORDER_ATOMIC];
};


// 手臂初始位置
Blockly.Arduino['picar_inPosition'] = function(block) {
  return 'inPosition();\n';
};

// 手臂合起
Blockly.Arduino['picar_closeHands'] = function(block) {
  return 'closeHands();\n';
};


// 手臂張開
Blockly.Arduino['picar_openHands'] = function(block) {
  return 'openHands();\n';
};


// 燈光閃爍
Blockly.Arduino['picar_flashingLight'] = function(block) {
  return 'flashingLight();\n';
};


// 播放彩蛋旋律
Blockly.Arduino['picar_easterEgg'] = function(block) {
  var tempo = Blockly.Arduino.valueToCode(block, 'TEMPO', Blockly.Arduino.ORDER_ATOMIC) || '1000';
  return 'easterEgg(' + tempo + ');\n';
};


// 自由寫
Blockly.Arduino['picar_rawCode'] = function(block) {
  var code = block.getFieldValue('CODE');
  return code + '\n'; // Output the text as-is, with a newline
};
